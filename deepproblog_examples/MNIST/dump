Output path:  output/distr_VARX_CONST/
Caching ACs
Prepare Bumm
exact_engine.prepare.new_es [number([],Result,Result)]
exact_engine.prepare.new_es [number([H | T],Acc,Result) :- digit(H,Nr), Acc2 is Nr+10*Acc, number(T,Acc2,Result)]
exact_engine.prepare.new_es [number(X,Y) :- number(X,0,Y)]
exact_engine.prepare.new_es [multi_addition(X,Y,Z) :- number(X,X2), number(Y,Y2), Z is X2+Y2]
exact_engine.prepare.new_es [addition(Img1,Img2,Sum) :- digit(Img1,D1), digit(Img2,D2), Sum is D2+D1]
exact_engine.prepare.new_es [prototype(X,tensor(prototype(X))) :- between(0,9,X)]
exact_engine.prepare.new_es [P0::digit(I,0); P1::digit(I,1); P2::digit(I,2); P3::digit(I,3); P4::digit(I,4); P5::digit(I,5); P6::digit(I,6); P7::digit(I,7); P8::digit(I,8); P9::digit(I,9) :- all_prob(I,[0, 1, 2, 3, 4, 5, 6, 7, 8, 9],[P0, P1, P2, P3, P4, P5, P6, P7, P8, P9])]
exact_engine.prepare.new_es [maplist(_,[],[])]
exact_engine.prepare.new_es [maplist(P,[H1 | T1],[H2 | T2]) :- call(P,H1,H2), maplist(P,T1,T2)]
exact_engine.prepare.new_es [map_encode_decode(Image,[],[])]
exact_engine.prepare.new_es [map_encode_decode(Image,[Prot | Prototypes],[P | Probs]) :- encode_decode(Image,Prot,P), map_encode_decode(Image,Prototypes,Probs)]
exact_engine.prepare.new_es [all_prob(Image,Classes,Dists) :- maplist(prototype,Classes,Prototypes), maplist(encode_decode(Image),Prototypes,Dists)]
exact_engine.prepare.new_es [encode_decode(Image,Prototype,P) :- encode(Image,Prototype,P1), decode(Prototype,Image,P2), mul(P1,P2,P)]
exact_engine.prepare.new_es [encode(Image,Latent,P) :- ground(Image), encoder(Image,Latent2), lat_similar(Latent,Latent2,P)]
exact_engine.prepare.new_es [encode(Image,Latent,1.0) :- var(Image), decoder(Latent,Image)]
exact_engine.prepare.new_es [decode(Latent,Image,P) :- ground(Latent), decoder(Latent,Image2), im_similar(Image,Image2,P)]
exact_engine.prepare.new_es [decode(Latent,Image,1.0) :- var(Latent), encoder(Image,Latent)]
exact_engine.prepare.e.probability.length (encoder, [Image], Latent)
exact_engine.prepare.new_es [encoder(Image,Latent) :- encoder_extern_nocache_([Image],Latent)]
exact_engine.prepare.e.probability.length (decoder, [Latent], Image)
exact_engine.prepare.new_es [decoder(Latent,Image) :- decoder_extern_nocache_([Latent],Image)]
exact_engine.prepare.new_es [im_similar(X,X,1.0)]
exact_engine.prepare.new_es [im_similar(Image1,Image2,P) :- Image1\=Image2, mse(Image1,Image2,P)]
exact_engine.prepare.new_es [lat_similar(X,X,1.0)]
exact_engine.prepare.new_es [lat_similar(Lat1,Lat2,P) :- Lat1\=Lat2, likelihood(Lat1,Lat2,P)]
exact_engine.model.networks[network].det True
exact_engine.model.networks[network].det True
Training  for 10 epoch(s)
Epoch 1
train.get_loss.batch [(1.0::digit(tensor(train(a)),5), {a: 0}), (1.0::digit(tensor(train(a)),0), {a: 1}), (1.0::digit(tensor(train(a)),4), {a: 2}), (1.0::digit(tensor(train(a)),1), {a: 3}), (1.0::digit(tensor(train(a)),9), {a: 4}), (1.0::digit(tensor(train(a)),2), {a: 5}), (1.0::digit(tensor(train(a)),1), {a: 6}), (1.0::digit(tensor(train(a)),3), {a: 7}), (1.0::digit(tensor(train(a)),1), {a: 8}), (1.0::digit(tensor(train(a)),4), {a: 9}), (1.0::digit(tensor(train(a)),3), {a: 10}), (1.0::digit(tensor(train(a)),5), {a: 11})]
solver.cache.batch [(1.0::digit(tensor(train(a)),5), {a: 0}), (1.0::digit(tensor(train(a)),0), {a: 1}), (1.0::digit(tensor(train(a)),4), {a: 2}), (1.0::digit(tensor(train(a)),1), {a: 3}), (1.0::digit(tensor(train(a)),9), {a: 4}), (1.0::digit(tensor(train(a)),2), {a: 5}), (1.0::digit(tensor(train(a)),1), {a: 6}), (1.0::digit(tensor(train(a)),3), {a: 7}), (1.0::digit(tensor(train(a)),1), {a: 8}), (1.0::digit(tensor(train(a)),4), {a: 9}), (1.0::digit(tensor(train(a)),3), {a: 10}), (1.0::digit(tensor(train(a)),5), {a: 11})]
solver.cache <deepproblog.utils.cache.Cache object at 0x7fb9c0a03a90>
cache.self.first <bound method Cache.get_from_dict of <deepproblog.utils.cache.Cache object at 0x7fb9c0a03a90>>
item:  (1.0::digit(tensor(train(a)),5), {a: 0})
cache_key digit(tensor(train(a)),5)
exact_engine.det_predicate.arguments:  [tensor(train(a))]
MNIST_Images.__getitem__.item (a,)
